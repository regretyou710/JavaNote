# 為什麽要有類的繼承性?(繼承性的好處)
1. 減少了代碼的冗余，提高了代碼的覆用性
2. 便於功能的擴展
3. 為之後多態性的使用，提供了前提

# 繼承性的格式:
class A extends B{}
* A:子類、派生類、subclass
* B:父類、超類、基類、superclass

# 子類繼承父類以後有哪些不同?
1. 體現:一旦子類A繼承父類B以後，子類A中就獲取了父類B中聲明的所有的屬性和方法。
   * 特別的，父類中聲明為private的屬性或方法，子類繼承父類以後，仍然認為獲取了父類中私的結構。只因為封裝性的影響，使得子類不能直接調用父類的結構而已。
2. 子類繼承父類以後，還可以聲明自己特有的屬性或方法:實現功能的拓展。
    * 子類和父類的關系，不同於子集和集合的關系。
    * extends:延展、擴展

# Java中繼承性的說明
1. 一個類可以被多個子類繼承。
2. Java中類的單繼承性:一個類只能有一個父類
3. 子父類是相對的概念。
4. 子類直接繼承的父類，稱為:直接父類。間接繼承的父類稱為:間接父類
5. 子類繼承父類以後，就獲取了直接父類以及所間接父類中聲明的屬性和方法

# java.lang.Object類的理解
1. 如果我們沒顯式的聲明一個類的父類的話，則此類繼承於java.lang.Object類
2. 所的java類(除java.lang.Object類之外都直接或間接的繼承於java.lang.Object類
3. 意味著，所的java類具有java.lang.Object類聲明的功能。

# 什麽是多態性?什麽是虛擬方法調用?
對象的多態性:父類的引用指向子類的對象。
Person p = new Man();
p.eat();
調用方法時，編譯時看左邊，運行時看右邊。

# 一個類可以有幾個直接父類?
只有一個

# 一個父類可有多少個子類?
多個

# 子類能獲取直接父類的父類中的結構嗎?
可以

# 子類能否獲取父類中private權限的屬性或方法?
可以

# 方法的重寫(override/overwrite)的具體規則有哪些?
方法名、形參列表相同  
權限修飾符  
返回值  
拋出的異常  

# super調用構造器，有哪些具體的注意點
this(形參列表):本類重載的其它的構造器  
super(形參列表):調用父類中指定的構造器  
n – 1 

# 什麽是方法的重寫(override 或 overwrite)?
子類繼承父類以後，可以對父類中同名同參數的方法，進行覆蓋操作

* 應用:  
重寫以後，當創建子類對象以後，通過子類對象調用子父類中的同名同參數的方法時，實際執行的是子類重寫父類的方法。

* 重寫的規則:
```
	方法的聲明: 權限修飾符  返回值類型  方法名(形參列表) throws 異常的類型{
  						//方法體
  					}
  		約定俗稱:子類中的叫重寫的方法，父類中的叫被重寫的方法
  		  1. 子類重寫的方法的方法名和形參列表與父類被重寫的方法的方法名和形參列表相同
          2. 子類重寫的方法的權限修飾符不小於父類被重寫的方法的權限修飾符
       	>特殊情況:子類不能重寫父類中聲明為private權限的方法
          3. 返回值類型:
       	>父類被重寫的方法的返回值類型是void，則子類重寫的方法的返回值類型只能是void
       	>父類被重寫的方法的返回值類型是A類型，則子類重寫的方法的返回值類型可以是A類或A類的子類
       	>父類被重寫的方法的返回值類型是基本數據類型(比如:double)，則子類重寫的方法的返回值類型必須是相同的基本數據類型(必須也是double)
 		  4. 子類重寫的方法拋出的異常類型不大於父類被重寫的方法拋出的異常類型(具體放到異常處理時候講)
 	**********************************************************************
     子類和父類中的同名同參數的方法要麽都聲明為非static的(考慮重寫，要麽都聲明為static的(不是重寫))。	
```

# 區分方法的重寫和重載?
答:
1. 二者的概念:
2. 重載和重寫的具體規則
3. 重載:不表現為多態性。重寫:表現為多態性。  
重載，是指允許存在多個同名方法，而這些方法的參數不同。編譯器根據方法不同的參數表，對同名方法的名稱做修飾。對於編譯器而言，這些同名方法就成了不同的方法。它們的調用地址在編譯期就綁定了。Java的重載是可以包括父類和子類的，即子類可以重載父類的同名不同參數的方法。
所以:對於重載而言，在方法調用之前，編譯器就已經確定了所要調用的方法，這稱為“早綁定”或“靜態綁定”；

而對於多態，只等到方法調用的那一刻，解釋運行器才會確定所要調用的具體方法，這稱為“晚綁定”或“動態綁定”。 

引用一句Bruce Eckel的話:“不要犯傻，如果它不是晚綁定，它就不是多態。”

# super
1. super 關鍵字可以理解為:父類的
2. 可以用來調用的結構:
屬性、方法、構造器
3. super調用屬性、方法:  
3.1 我們可以在子類的方法或構造器中。通過使用"super.屬性"或"super.方法"的方式，顯式的調用父類中聲明的屬性或方法。但是，通常情況下，我們習慣省略"super."  
3.2 特殊情況:當子類和父類中定義了同名的屬性時，我們要想在子類中調用父類中聲明的屬性，則必須顯式的使用"super.屬性"的方式，表明調用的是父類中聲明的屬性。    
3.3 特殊情況:當子類重寫了父類中的方法以後，我們想在子類的方法中調用父類中被重寫的方法時，則必須顯式的使用"super.方法"的方式，表明調用的是父類中被重寫的方法。

4. super調用構造器:  
4.1  我們可以在子類的構造器中顯式的使用"super(形參列表)"的方式，調用父類中聲明的指定的構造器  
4.2 "super(形參列表)"的使用，必須聲明在子類構造器的首行！  
4.3 我們在類的構造器中，針對於"this(形參列表)"或"super(形參列表)"只能二選一，不能同時出現  
4.4 在構造器的首行，沒顯式的聲明"this(形參列表)"或"super(形參列表)"，則默認調用的是父類中空參的構造器:super()  
4.5 在類的多個構造器中，至少一個類的構造器中使用了"super(形參列表)"，調用父類中的構造器

# 子類對象實例化全過程
1. 從結果上看:繼承性
   * 子類繼承父類以後，就獲取了父類中聲明的屬性或方法。
   * 創建子類的對象，在堆空間中，就會加載所父類中聲明的屬性。
2. 從過程上看:  
當我們通過子類的構造器創建子類對象時，我們一定會直接或間接的調用其父類的構造器，進而調用父類的父類的構造器，...直到調用了java.lang.Object類中空參的構造器為止。正因為加載過所的父類的結構，所以才可以看到內存中父類中的結構，子類對象才可以考慮進行調用。